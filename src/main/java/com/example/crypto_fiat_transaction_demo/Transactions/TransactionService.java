package com.example.crypto_fiat_transaction_demo.Transactions;


import com.example.crypto_fiat_transaction_demo.User.User;
import com.example.crypto_fiat_transaction_demo.User.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.security.Timestamp;
import java.util.Map;

@Service
public class TransactionService {

    // Constructor injection for multiple repositories. we inject repositories for data access purposes
    private final UserRepository userRepository;
    private final TransactionRepository transactionRepository;

    public TransactionService(UserRepository userRepository, TransactionRepository transactionRepository){
        this.userRepository = userRepository;
        this.transactionRepository = transactionRepository;
    }

    @Autowired
    private RestTemplate restTemplate;

    // Do not forget break statements in the switch cases
    // performTransaction is a dual service, being able to alter both transactionRepository and userRepository, but only need to return transactionRepository
    public Transaction performTransaction(Long userid, String source, String target, double amount){
        // userRepository part: subtracting from source and adding to target
        User user = userRepository.findById(userid).orElseThrow(() -> new RuntimeException("User not found"));
        // conversionRate from http method below
        double conversionRate = getConversionRate(source, target);
        double convertedAmount = amount * conversionRate;
        // Source Switch statements
        switch (source.toLowerCase()){
            case "usd":
                double finalUsdAmount = user.getUSD()-amount;
                if (finalUsdAmount < 0) {
                    throw new IllegalArgumentException("Insufficient USD!");
                } else {
                    user.setUSD(finalUsdAmount);
                }
                break;
            case "bitcoin":
                double finalBitcoinAmount = user.getBitcoin()-amount;
                if (finalBitcoinAmount < 0) {
                    throw new IllegalArgumentException("Insufficient Bitcoin!");
                } else {
                    user.setUSD(finalBitcoinAmount);
                }
                break;
            case "etherueum":
                double finalEthereumAmount = user.getEthereum()-amount;
                if (finalEthereumAmount < 0) {
                    throw new IllegalArgumentException("Insufficient Ethereum!");
                } else {
                    user.setEthereum(finalEthereumAmount);
                }
                break;
            case "bnb":
                double finalBnbAmount = user.getBNB()-amount;
                if (finalBnbAmount < 0) {
                    throw new IllegalArgumentException("Insufficient BNB!");
                } else {
                    user.setBNB(finalBnbAmount);
                }
                break;
        }
        // Target switch statements
        switch (target.toLowerCase()){
            case "usd":
                user.setUSD(user.getUSD()+convertedAmount);
                break;
            case "bitcoin":
                user.setBitcoin(user.getBitcoin()+convertedAmount);
                break;
            case "ethereum":
                user.setEthereum(user.getEthereum()+convertedAmount);
                break;
            case "bnb":
                user.setBNB(user.getBNB()+convertedAmount);
                break;
        }
        // At the end must save the user's current balances into the userRepository
        userRepository.save(user);

        // transactionRepository part where we record down the transaction into the transactionRepository
        Transaction transaction = new Transaction();
        transaction.setUserid(userid);
        transaction.setSource(source);
        transaction.setTarget(target);
        transaction.setAmount(amount);
        transaction.setConversion_rate(conversionRate);
        transaction.setTimestamp(new java.sql.Timestamp(System.currentTimeMillis()));
        // At the end must save the transaction into the transactionRepository
        // This returns the saved Transaction object, which may have additional information after saving (like the autogenerated transaction ID)
        // Also it confirms the success of it
        return transactionRepository.save(transaction);
    }

    // getConversionRate is a method which calls an external API
    public double getConversionRate(String source, String target){
        // Step 1: Define CoinGecko api url
        String coinApiUrl = "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,binancecoin&vs_currencies=usd";

        // Step 2: Make the API call and capture the response
        ResponseEntity<Map<String, Map<String, Double>>> response = restTemplate.exchange( // .exchange is used to execute a http request
                coinApiUrl, // the URL we are sending the request to
                HttpMethod.GET, // the HTTP method we are using, which is GET in this case, there are many others just type HttpMethod. and the list will show
                null, // where we would normally pass a HttpEntity object, which can contain Headers(authorization tokens or custom headers) and Body (for passing the request body for POST or PUT requests)
                new ParameterizedTypeReference<Map<String, Map<String, Double>>>() {} // the type of response expected
        );

        // Step 3: Parse the response and extract the conversion rates
        Map<String, Map<String, Double>> rates = response.getBody();

        // Check if rates map is not null
        if (rates != null) {
            System.out.println(rates);  // Should print: {binancecoin={usd=551.63}, bitcoin={usd=59708.0}, ethereum={usd=2416.38}}
        }
        if (source.toLowerCase().equals("bnb")){
            source="binancecoin";
        }
        if (target.toLowerCase().equals("bnb")){
            target = "binancecoin";
        }

        // If either source or target is USD, then the corresponding if statement will not take place, and the RateInUSD will just be 1.0 since 1=1
        double sourceRateInUsd = 1.0;
        double targetRateInUsd = 1.0;


        if (!source.equalsIgnoreCase("usd")){
            sourceRateInUsd = rates.get(source.toLowerCase()).get("usd");
        }

        if (!target.equalsIgnoreCase("usd")){
            targetRateInUsd = rates.get(target.toLowerCase()).get("usd");
        }

        return sourceRateInUsd/targetRateInUsd;
    }
}